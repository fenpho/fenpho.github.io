<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
Theme By Fenpho
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>Typescript入门 | Fenpho</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Fenpho">
    <meta name="author" content="Fenpho">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Fenpho" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml">
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">首页</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">归档</a></li>
            <!-- Dropdown Menu -->
			 
            
        	<li>
        		<a class="sb-toggle-submenu">分类<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/前端漫谈/" class="animsition-link">前端漫谈<small>(22)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">友情链接<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="https://fenpho.github.io/" class="animsition-link">Fenpho</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about" class="animsition-link" title="about">关于</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">订阅</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Fenpho</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/fenpho" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">更多</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-05-17T10:32:04.000Z" itemprop="datePublished">
          2022-05-17
      </time>
    
    
    | 
    <a href='/tags/typescript/'>typescript</a>
    
    
</span>
                <h1>Typescript入门</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h3 id="阶段一、TS的理论基础和工作流程"><a href="#阶段一、TS的理论基础和工作流程" class="headerlink" title="阶段一、TS的理论基础和工作流程"></a>阶段一、TS的理论基础和工作流程</h3><h4 id="1-什么是TypeScript"><a href="#1-什么是TypeScript" class="headerlink" title="1. 什么是TypeScript"></a>1. 什么是TypeScript</h4><p><img src="1.png" alt="image.png"></p>
<p>script好理解，就是脚本，而type则是来自typing（强类型），有以下几个优势</p>
<p><strong>typing: 强类型</strong></p>
<ul>
<li>在原生JavaScript的基础上加上了一层类型定义</li>
<li>规范我们的代码</li>
<li>代码编译阶段就能及时发现错误</li>
</ul>
<p>简单来说：Typescript就是JavaScript 的类型化超集</p>
<blockquote>
<p>注：Typescript无法在浏览器中运行，需要先编译成JavaScript</p>
</blockquote>
<h4 id="2-为什么要使用TypeScript"><a href="#2-为什么要使用TypeScript" class="headerlink" title="2. 为什么要使用TypeScript"></a>2. 为什么要使用TypeScript</h4><ul>
<li>类型检查</li>
<li>解放劳动力</li>
<li>帮助我们写出更高质量的代码</li>
<li>类型推演与类型匹配</li>
<li>开发编译时报错</li>
<li>极大程度的避免了低级错误</li>
<li>支持JavaScript最新特性（包含ES6/7/8）</li>
</ul>
<h4 id="3-开发环境配置"><a href="#3-开发环境配置" class="headerlink" title="3. 开发环境配置"></a>3. 开发环境配置</h4><p>官网：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a></p>
<p>安装ts编译器(前提：已安装node，若没有，前往：nodejs.org，下载安装LTS版本即可)<br><code>npm install -g typescript</code><br>推荐使用编辑器：Visual Studio Code，地址：<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<h4 id="4-TypeScript工作流"><a href="#4-TypeScript工作流" class="headerlink" title="4. TypeScript工作流"></a>4. TypeScript工作流</h4><p><img src="2.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;tsc 命令编译</span><br><span class="line">tsc hello.ts</span><br><span class="line">&#x2F;&#x2F;可以同时编译多个ts文件</span><br><span class="line">tsc fileName1.ts fileName2.ts fileName3.ts</span><br><span class="line">&#x2F;&#x2F;在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译.</span><br><span class="line">tsc fileName.ts --watch</span><br></pre></td></tr></table></figure>
<p>tsc 常用编译参数如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">编译参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">–help</td>
<td align="left">显示帮助信息</td>
</tr>
<tr>
<td align="left">–module</td>
<td align="left">载入扩展模块</td>
</tr>
<tr>
<td align="left">–target</td>
<td align="left">设置 ECMA 版本</td>
</tr>
<tr>
<td align="left">–declaration</td>
<td align="left">额外生成一个 .d.ts 扩展名的文件。<code>tsc a.ts --declaration</code>命令会生成 a.d.ts、a.js 两个文件</td>
</tr>
<tr>
<td align="left">–removeComments</td>
<td align="left">删除文件的注释</td>
</tr>
<tr>
<td align="left">–out</td>
<td align="left">编译多个文件并合并到一个输出的文件</td>
</tr>
<tr>
<td align="left">–sourcemap</td>
<td align="left">生成一个 sourcemap (.map) 文件。sourcemap 是一个存储源代码与编译代码对应位置映射的信息文件</td>
</tr>
<tr>
<td align="left">–module noImplicitAny</td>
<td align="left">在表达式和声明上有隐含的 any 类型时报错</td>
</tr>
<tr>
<td align="left">–watch</td>
<td align="left">在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译</td>
</tr>
</tbody></table>
<h3 id="阶段二、TS的基础知识"><a href="#阶段二、TS的基础知识" class="headerlink" title="阶段二、TS的基础知识"></a>阶段二、TS的基础知识</h3><h4 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h4><p>JavaScript中作用域一般只分为全局函数两种，但是使用let和const声明的变量则有块级作用域<br>声明变量：<br>var：作用域为函数内或全局<br>let：块级作用域</p>
<p>声明常量：<br>const 块级作用域</p>
<h4 id="2-TypeScript的类型"><a href="#2-TypeScript的类型" class="headerlink" title="2. TypeScript的类型"></a>2. TypeScript的类型</h4><p>准确来说目前JS数据类型总共有8种：<br>7种基本（原始）类型：String Number Boolean Null Undefined Symbol BigInt<br>1种引用（对象）类型：Object<br>Object又可以细分为： Object本身 Array Date Function RegExp</p>
<p>JS的类型判断方式</p>
<blockquote>
<ol>
<li>Object.prototype.toString.call() 方法,这个方法可以判断任何的类型,返回的是一个字符串</li>
<li>typeof() 方法，这个方法用来准确判断基本类型（除了null），返回的也是一个字符串</li>
<li>instanceof() 方法，这个方法用来判断对象类型,返回一个布尔值，如果判断基本类型，那么会输出false</li>
<li>特定的判断方法</li>
</ol>
<p>1).数组的isArray() 方法，判断是否为数组，返回true或者false.<br>2).isNaN() 方法，在 JavaScript 中，NaN 是一个不合法的数字。 Number.isNaN () 方法用于判断传递的值是否为 NaN，并且检查其类型是否为 Number，如果值为 NaN 且类型为 Number，则返回 true，否则返回 false</p>
</blockquote>
<p>ts数据类型，新增了如下5种基本数据类型：tuple（元组），enum（枚举），void，never，any<br>3种高级类型：union（组合类型）、nullable（可空类型）、literal（预定义类型）</p>
<h4 id="3-数字、布尔和字符串"><a href="#3-数字、布尔和字符串" class="headerlink" title="3. 数字、布尔和字符串"></a>3. 数字、布尔和字符串</h4><p>number 数字<br>对数字的表示只有一个很笼统的number来表示，即能表示整数，也能表示浮点数，甚至还能表示负数<br>如：1、5.3、-10</p>
<p>string 字符串<br>使用单引号、双引号或者反引号创建<br>如：’hello’、”hello”、`hello`</p>
<p>boolean 布尔<br>表示真假，只有true和false两个值</p>
<h4 id="4-数组和元组"><a href="#4-数组和元组" class="headerlink" title="4. 数组和元组"></a>4. 数组和元组</h4><p>array 数组<br>创建数组可以采用两种方式：<br>1）字面量：[]<br>2）new对象：new Array()</p>
<p>tuple 元组<br>固定长度和类型的array</p>
<h4 id="5-联合与字面量类型"><a href="#5-联合与字面量类型" class="headerlink" title="5.联合与字面量类型"></a>5.联合与字面量类型</h4><p>union 联合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">let</span> union: string | number </span><br><span class="line">union = <span class="number">2</span> <span class="comment">// ok</span></span><br><span class="line">union = <span class="string">&#x27;aaa&#x27;</span> <span class="comment">// ok</span></span><br><span class="line">union = <span class="literal">true</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>literal 字面量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">let</span> literal：<span class="string">&#x27;as number&#x27;</span> | <span class="number">1</span> | <span class="number">2</span></span><br><span class="line">literal = <span class="string">&#x27;as number&#x27;</span> <span class="comment">// ok</span></span><br><span class="line">literal = <span class="number">2</span> <span class="comment">// ok</span></span><br><span class="line">literal = <span class="number">3</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h4 id="6-枚举类型"><a href="#6-枚举类型" class="headerlink" title="6. 枚举类型"></a>6. 枚举类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> color = color.blue;</span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// 输出为2，对应Color中blue定义所在的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动指定顺序（顺序可以为数字或字符串等）</span></span><br><span class="line">enum Color2 &#123;</span><br><span class="line">  red = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  green = <span class="number">10</span>,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-Any-与-Unknow"><a href="#7-Any-与-Unknow" class="headerlink" title="7. Any 与 Unknow"></a>7. Any 与 Unknow</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// any</span></span><br><span class="line"><span class="keyword">let</span> randomValue: any = <span class="number">666</span></span><br><span class="line">randomValue = <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line">randomValue = <span class="string">&#x27;add&#x27;</span> <span class="comment">// ok</span></span><br><span class="line">randomValue = &#123;&#125; <span class="comment">// ok</span></span><br><span class="line">randomValue() <span class="comment">// 写时没问题，编译会报错</span></span><br><span class="line">randomValue.toUpperCase()</span><br><span class="line"></span><br><span class="line"><span class="comment">// unknow 不保证类型，但是保证类型安全</span></span><br><span class="line"><span class="keyword">let</span> randomValue1: unknown = <span class="number">666</span></span><br><span class="line">randomValue1 = <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line">randomValue1 = <span class="string">&#x27;add&#x27;</span> <span class="comment">// ok</span></span><br><span class="line">randomValue1 = &#123;&#125; <span class="comment">// ok</span></span><br><span class="line">randomValue1() <span class="comment">// error</span></span><br><span class="line">randomValue1.toUpperCase() <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> randomValue1 === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  randomValue1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> randomValue1 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  randomValue1.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-Void、Undefined与Never"><a href="#8-Void、Undefined与Never" class="headerlink" title="8. Void、Undefined与Never"></a>8. Void、Undefined与Never</h4><p>void只在ts中存在，表示不存在，undefined表示未定义，never用来控制逻辑流程，表示永远不可能执行完成。</p>
<h4 id="9-类型适配器（类型断言）Type-Assertions"><a href="#9-类型适配器（类型断言）Type-Assertions" class="headerlink" title="9. 类型适配器（类型断言）Type Assertions"></a>9. 类型适配器（类型断言）Type Assertions</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message: any</span><br><span class="line">message = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">message.endsWith(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">(&lt;string&gt;message).endsWith(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">(message <span class="keyword">as</span> string).endsWith(<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用类型断言一定要对使用的变量类型有清楚的了解，否则会导致各种不可预料的错误</p>
</blockquote>
<h4 id="10-函数类型"><a href="#10-函数类型" class="headerlink" title="10. 函数类型"></a>10. 函数类型</h4><p>在 TypeScript里，我们可以通过 function 字面量和箭头函数的形式定义函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>还可以显式指定函数参数和返回值的类型，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: number, <span class="attr">b</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述示例中，参数名后的 :number 表示参数类型都是数字类型，圆括号后的 : number则表示返回值类型也是数字类型。</p>
<p>下面介绍一下返回值类型和参数类型<br>返回值类型<br>在 JavaScript 中，如果一个函数可以没有显式 return，此时函数的返回值是 undefined：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，在 TypeScript 中，如果我们显式声明函数的返回值类型为 undfined，会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">undefined</span> </span>&#123; </span><br><span class="line"><span class="comment">// error TS2355: A function whose declared type is neither &#x27;void&#x27; nor &#x27;any&#x27; must return a value.</span></span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，正确的做法是使用void 类型来表示函数没有返回值的类型（void 类型很少用到，这基本是唯一有用的场景），示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line">func().someFunc(); <span class="comment">// error TS2339: Property &#x27;someFunc&#x27; does not exist on type &#x27;void&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用类似定义箭头函数的语法来表示函数类型的参数和返回值类型，此时 =&gt; 仅仅用来定义一个函数类型而不是实现这个函数。</p>
<p>需要注意的是，这里的 =&gt;与 ES6 中箭头函数的 =&gt; 有所不同。TypeScript 函数类型中的 =&gt; 用来表示函数的定义，其左侧是函数的参数类型，右侧是函数的返回值类型；而 ES6 中的 =&gt; 是函数的实现。</p>
<p>如下示例中，先定义了一个函数类型（这里使用了类型别名 type），并且使用箭头函数实现了这个类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Adder = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> number; <span class="comment">// TypeScript 函数类型定义</span></span><br><span class="line"><span class="keyword">const</span> add: Adder = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b; <span class="comment">// ES6 箭头函数</span></span><br></pre></td></tr></table></figure>
<p>在对象中，除了使用这种声明语法，我们还可以使用类似对象属性的简写语法来声明函数类型的属性，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Entity &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> number;</span><br><span class="line">  del(a: number, <span class="attr">b</span>: number): number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> entity: Entity = &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b,</span><br><span class="line">  <span class="function"><span class="title">del</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在某种意义上来说，这两种形式都是等价的。但是很多时候，我们不必或者不能显式地指明返回值的类型，这就涉及可缺省和可推断的返回值类型</p>
<p>可缺省和可推断的返回值类型<br>函数返回值的类型可以在 TypeScript 中被推断出来，即可缺省</p>
<p>函数内是一个相对独立的上下文环境，我们可以根据入参对值加工计算，并返回新的值。从类型层面看，我们也可以通过类型推断加工计算入参的类型，并返回新的类型，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">one: string, two: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [two];</span><br><span class="line">  <span class="keyword">const</span> strs = [one];</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    nums,</span><br><span class="line">    strs</span><br><span class="line">  &#125; <span class="comment">// 返回 nums: number[]; strs: string[] 的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数类型</p>
<p>了解了定义函数的基本语法以及返回值类型后，再来详细看一下<strong>可选参数</strong>、<strong>默认参数</strong>、<strong>剩余参数</strong>的几个特性。</p>
<p><strong>可选参数和默认参数</strong></p>
<p>在实际工作中，我们可能经常碰到函数参数可传可不传的情况，当然 TypeScript 也支持这种函数类型表达，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x?: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// undefined</span></span><br><span class="line">func(<span class="string">&#x27;777&#x27;</span>); <span class="comment">// 777</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们在类型标注的 : 前添加 ? 表示 func 函数的参数 x 是可缺省的</p>
<p>也就是说参数 x 的类型可能是 undefined（不传入实参）类型或者是 string 类型（传入 ‘777’ 实参），那是不是意味着可缺省和类型是 undefined 等价呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">x?: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">x: string | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">func1(); <span class="comment">// undefined</span></span><br><span class="line">func1(<span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line">func2(); <span class="comment">// error TS2554: Expected 1 arguments, but got 0.</span></span><br><span class="line">func2(<span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>这里的 ?: 表示参数可以缺省、可以不传，也就是说调用函数时，我们可以不显式传入参数。但是，如果我们声明了参数类型为 xxx | undefined，就表示函数参数是不可缺省且类型必须是 xxx 或者 undfined</p>
<p>因此，在上述代码中，func2 函数如果不显示传入函数的参数，TypeScript 就会报一个 ts(2554) 的错误，即函数需要 1 个参数，但是我们只传入了 0 个参数。</p>
<p>在 ES6 中支持函数默认参数的功能，而 TypeScript 会根据函数的默认参数的类型来推断函数参数的类型，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x = <span class="string">&#x27;777&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// 777</span></span><br><span class="line">func(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// hello world</span></span><br><span class="line">func(<span class="number">1</span>); <span class="comment">// error TS2345: Argument of type &#x27;1&#x27; is not assignable to parameter of type &#x27;string | undefined&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，根据函数的默认参数 ‘777’ ，TypeScript 推断出了 x 的类型为 string | undefined</p>
<p>剩余参数<br>在 ES6 中，JavaScript 支持函数参数的剩余参数，它可以把多个参数收集到一个变量中。同样，在TypeScript 中也支持这样的参数类型定义，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...nums: number[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>); <span class="comment">// error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，sum 是一个求和的函数，…nums 将函数的所有参数收集到了变量 nums 中，而 nums 的类型应该是 number[]，表示所有被求和的参数是数字类型。因此，sum(1, ‘2’) 抛出了一个 ts(2345) 的错误，因为参数 ‘2’ 并不是 number 类型。</p>
<p>如果这么写就可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...nums: (number | string)[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.reduce&lt;number&gt;(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + <span class="built_in">Number</span>(b), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>函数的每一个参数的类型就是联合类型 number | string，因此 sum(1, ‘2’, 3) 的类型检查也就通过了。</p>
<p>this<br>众所周知，在 JavaScript 中，函数 this 的指向一直是一个令人头痛的问题。因为 this 的值需要等到函数被调用时才能被确定，更别说通过一些方法还可以改变 this 的指向。也就是说 this 的类型不固定，它取决于执行时的上下文。</p>
<p>但是，使用了 TypeScript 后，我们就不用担心这个问题了。通过指定 this 的类型（严格模式下，必须显式指定 this 的类型），当我们错误使用了 this，TypeScript 就会提示我们，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// error TS2683: &#x27;this&#x27; implicitly has type &#x27;any&#x27; because it does not have a type annotation.</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果我们直接调用 say 函数，this 应该指向全局 window 或 global（Node 中）。但是，在 strict 模式下的 TypeScript 中，它会提示 this 的类型是 any，此时就需要我们手动显式指定类型了。</p>
<p>在 TypeScript 中，我们只需要在函数的第一个参数中声明 this 指代的对象（即函数被调用的方式）即可，比如最简单的作为对象的方法的 this 指向，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"><span class="built_in">this</span>: Window, name: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.func = func;</span><br><span class="line"><span class="built_in">window</span>.func(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  func</span><br><span class="line">&#125;;</span><br><span class="line">obj.func(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// error TS2684: The &#x27;this&#x27; context of type &#x27;&#123; func: (this: Window, name: string) =&gt; void; &#125;&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;Window&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们在 window 对象上增加 say 的属性为函数 say。那么调用 window.say() 时，this 指向即为 window 对象。</p>
<p>调用 obj.say() 后，此时 TypeScript 检测到 this 的指向不是 window，于是抛出了如下所示的一个 ts(2684) 错误。</p>
<p>需要注意的是，如果我们直接调用 func()，this 实际上应该指向全局变量 window，但是因为 TypeScript 无法确定 func 函数被谁调用，所以将 this 的指向默认为 void，也就提示了一个 ts(2684) 错误。 如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="string">&#x27;777&#x27;</span>); <span class="comment">// error TS2684: The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;Window&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>此时，我们可以通过调用 window.say() 来避免这个错误，这也是一个安全的设计。因为在 JavaScript 的严格模式下，全局作用域函数中 this 的指向是 undefined。</p>
<p>同样，定义对象的函数属性时，只要实际调用中 this 的指向与指定的 this 指向不同，TypeScript 就能发现 this 指向的错误，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  say(<span class="built_in">this</span>: Person): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jae&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = person.say;</span><br><span class="line">func(); <span class="comment">// error TS2684: The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;Person&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>函数重载<br>JavaScript 是一门动态语言，针对同一个函数，它可以有多种不同类型的参数与返回值，这就是函数的多态。</p>
<p>而在 TypeScript 中，也可以相应地表达不同类型的参数和返回值的函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">x: string | number | <span class="literal">null</span></span>): <span class="title">string</span> | <span class="title">number</span> | -1 </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x1 = convert(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// =&gt; string | number</span></span><br><span class="line"><span class="keyword">const</span> x2 = convert(<span class="number">1</span>); <span class="comment">// =&gt; string | number</span></span><br><span class="line"><span class="keyword">const</span> x3 = convert(<span class="literal">null</span>); <span class="comment">// =&gt; string | number</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们把 convert 函数的 string 类型的值转换为 number 类型，number 类型转换为 string 类型，而将 null 类型转换为数字 -1。此时， x1、x2、x3 的返回值类型都会被推断成 string | number</p>
<p>那么，有没有一种办法可以更精确地描述参数与返回值类型约束关系的函数类型呢？有，这就是函数重载。如下示例中先定义了三种各不相同的函数类型列表，并描述了不同的参数类型对应不同的返回值类型，而后才是函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">x: string</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">x: number</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">x: <span class="literal">null</span></span>): -1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">x: string | number | <span class="literal">null</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Number</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">String</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x1 = convert(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// =&gt; number</span></span><br><span class="line"><span class="keyword">const</span> x2 = convert(<span class="number">1</span>); <span class="comment">// =&gt; string</span></span><br><span class="line"><span class="keyword">const</span> x3 = convert(<span class="literal">null</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>类型谓词（is）<br>在 TypeScript 中，函数还支持另外一种特殊的类型描述，如下示例 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">s: unknown</span>): <span class="title">s</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> s === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">n: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> n === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isString(x)) &#123;...&#125; <span class="comment">// 没问题</span></span><br><span class="line">  <span class="keyword">if</span> (isNumber(x)) &#123;...&#125; <span class="comment">// error TS2345: Argument of type &#x27;unknown&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，在添加返回值类型的地方，通过“参数名 + is + 类型”的格式明确表明了参数的类型，进而引起类型缩小，所以类型谓词函数的一个重要的应用场景是实现自定义类型守卫</p>
<h3 id="阶段三、TS的面向对象"><a href="#阶段三、TS的面向对象" class="headerlink" title="阶段三、TS的面向对象"></a>阶段三、TS的面向对象</h3><h4 id="1-Object对象"><a href="#1-Object对象" class="headerlink" title="1. Object对象"></a>1. Object对象</h4><p><img src="3.png"></p>
<p>ts中无法访问对象未定义的属性或方法<br><img src="4.png"></p>
<p>若是将对象显示定义为any，那么就和js一样，可以访问未定义的属性和方法</p>
<h4 id="2-Interface接口"><a href="#2-Interface接口" class="headerlink" title="2. Interface接口"></a>2. Interface接口</h4><p>未加限制下的函数，可以任意入参<br><img src="5.png"></p>
<p>通过接口限制后的函数<br><img src="6.png"></p>
<h4 id="3-Class-类"><a href="#3-Class-类" class="headerlink" title="3. Class 类"></a>3. Class 类</h4><p><img src="7.png"><br><img src="8.png"><br><img src="9.png"></p>
<p>使用构造函数<br><img src="10.png"></p>
<p>参数初始化时必须传递<br><img src="11.png"></p>
<p>加上问号或者给予默认值，变为可选性，初始化如不知道参数可以不传递<br><img src="12.png"></p>
<p>使用访问修饰符，注意此时参数不允许可选，只允许赋初值<br><img src="13.png"></p>
<h4 id="4-Access-Modifier访问修饰符"><a href="#4-Access-Modifier访问修饰符" class="headerlink" title="4. Access Modifier访问修饰符"></a>4. Access Modifier访问修饰符</h4><p>限制外部对内部方法和属性的访问，默认情况下都为公有。<br><img src="14.png"></p>
<p>接口中定义的都是共有属性和方法，一旦改为私有，需要在接口进行相应修改，最简单的方式就是删除对应的。</p>
<p>getter和setter用于保留私有性的同时，允许外部对私有变量的访问（就是提供给外部获取和设置内部值的方法）<br><img src="15.png"></p>
<p>接口改造<br><img src="16.png"></p>
<p>通过geter取值<br><img src="17.png"></p>
<p>便捷写法<br><img src="18.png"></p>
<p>使用<br><img src="19.png"></p>
<p>接口也需要对应修改<br><img src="20.png"></p>
<p>便捷写法需要es5以上才支持，通常习惯上将私有变量前加上下划线’_’，报错如下：<br><img src="21.png"></p>
<p>错误处理：<br>tsc -t es5 xxx.ts</p>
<h4 id="5-Module-模块"><a href="#5-Module-模块" class="headerlink" title="5. Module 模块"></a>5. Module 模块</h4><p>使用关键字export导出模块，import导入模块<br><img src="22.png"></p>
<p><img src="23.png"></p>
<p>若是使用export default导出，导入时不需要花括号。</p>
<h4 id="6-Generics-泛型"><a href="#6-Generics-泛型" class="headerlink" title="6. Generics 泛型"></a>6. Generics 泛型</h4><p><img src="24.png"></p>
<p><img src="25.png"></p>
<p>不一定要使用T，可以是任意字符，只是约定俗成用T，也可以简单写成如下字面量形式<br><img src="26.png"></p>
<p>可以指定输出类型<br><img src="27.png"></p>
<p>多个类型处理<br><img src="28.png"><br><img src="29.png"></p>
<p>同样允许显示定义类型<br><img src="30.png"></p>
<p>设置默认类型<br><img src="31.png"></p>
<p>此时可以省略第二个泛型的定义<br><img src="32.png"></p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2022/09/15/npm%E5%8F%91%E5%8C%85%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/" style="float: left;">
        ← npm发包详细教程
    </a>
    
    
    <a class="pull-right" href="/2022/01/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
        正则表达式 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2017<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Fenpho. All Rights Reserved.
                </p>
                <p>Theme By <a href="#" style="color: #767D84">Fenpho</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/fenpho" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
